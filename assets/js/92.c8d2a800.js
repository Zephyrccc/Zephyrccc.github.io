(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{416:function(t,e,v){"use strict";v.r(e);var _=v(4),a=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"aes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aes"}},[t._v("#")]),t._v(" AES")]),t._v(" "),e("h2",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),e("p",[t._v("AES，高级加密标准，是采用区块加密的一种标准，又称Rijndael加密法。严格上来讲，AES和Rijndael又不是完全一样，AES的区块长度固定为128比特，秘钥长度可以是128、192或者256。Rijndael加密法可以支持更大范围的区块和密钥长度，Rijndael使用的密钥和区块长度均可以是128，192或256比特。 AES是对称加密最流行的算法之一")]),t._v(" "),e("h2",{attrs:{id:"aes的基本结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aes的基本结构"}},[t._v("#")]),t._v(" AES的基本结构")]),t._v(" "),e("p",[t._v("AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("AES")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("密钥长度（32位比特字)")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("分组长度(32位比特字)")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("加密轮数")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("AES-128")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("4")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("4")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("10")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("AES-192")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("6")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("4")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("12")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("AES-256")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("8")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("4")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("14")])])])]),t._v(" "),e("h2",{attrs:{id:"aes密钥扩展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aes密钥扩展"}},[t._v("#")]),t._v(" AES密钥扩展")]),t._v(" "),e("p",[t._v("AES首先将初始密钥输入到一个4*4的状态矩阵中，如下图所示")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_12.png",alt:"AES_12"}})]),t._v(" "),e("p",[t._v('这个44矩阵的每一列的4个字节组成一个字，矩阵4列的4个字依次命名为W[0]、W[1]、W[2]和W[3]，它们构成一个以字为单位的数组W。例如，设密钥K为"abcdefghijklmnop",则K0 = ‘a’,K1 = ‘b’, K2 = ‘c’,K3 = ‘d’,W[0] = “abcd”。\n接着，对W数组扩充40个新列，构成总共44列的扩展密钥数组。新列以如下的递归方式产生：\n1.如果i不是4的倍数，那么第i列由如下等式确定：\nW[i]=W[i-4]⨁W[i-1]\n2.如果i是4的倍数，那么第i列由如下等式确定：\nW[i]=W[i-4]⨁T(W[i-1])\n其中，T是一个有点复杂的函数。\n函数T由3部分组成：字循环、字节代换和轮常量异或，这3部分的作用分别如下。\na.字循环：将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]。\nb.字节代换：对字循环的结果使用S盒进行字节代换。\nc.轮常量异或：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。\n轮常量Rcon[j]是一个字，其值见下表。')]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("j")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("2")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("3")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("4")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("5")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("Rcon[j]")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("01 00 00 00")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("02 00 00 00")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("04 00 00 00")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("08 00 00 00")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("10 00 00 00")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("j")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("6")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("7")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("8")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("9")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("10")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("Rcon[j]")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("20 00 00 00")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("40 00 00 00")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("80 00 00 00")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1B 00 00 00")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("36 00 00 00")])])])]),t._v(" "),e("p",[t._v("下面举个例子：\n设初始的128位密钥为：\n3C A1 0B 21 57 F0 19 16 90 2E 13 80 AC C1 07 BD\n那么4个初始值为：\nW[0] = 3C A1 0B 21\nW[1] = 57 F0 19 16\nW[2] = 90 2E 13 80\nW[3] = AC C1 07 BD\n下面求扩展的第1轮的子密钥(W[4],W[5],W[6],W[7])。\n由于4是4的倍数，所以：\nW[4] = W[0] ⨁ T(W[3])\nT(W[3])的计算步骤如下：")]),t._v(" "),e("ul",[e("li",[t._v("循环地将W[3]的元素移位：AC C1 07 BD变成C1 07 BD AC;")]),t._v(" "),e("li",[t._v("将 C1 07 BD AC 作为S盒的输入，输出为78 C5 7A 91;")]),t._v(" "),e("li",[t._v("将78 C5 7A 91与第一轮轮常量Rcon[1]进行异或运算，将得到79 C5 7A 91，因此，T(W[3])=79 C5 7A 91，故W[4] = 3C A1 0B 21 ⨁ 79 C5 7A 91 = 45 64 71 B0\n其余的3个子密钥段的计算如下：\nW[5] = W[1] ⨁ W[4] = 57 F0 19 16 ⨁ 45 64 71 B0 = 12 94 68 A6\nW[6] = W[2] ⨁ W[5] =90 2E 13 80 ⨁ 12 94 68 A6 = 82 BA 7B 26\nW[7] = W[3] ⨁ W[6] = AC C1 07 BD ⨁ 82 BA 7B 26 = 2E 7B 7C 9B\n所以，第一轮的密钥为 45 64 71 B0 12 94 68 A6 82 BA 7B 26 2E 7B 7C 9B")])]),t._v(" "),e("h2",{attrs:{id:"算法原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法原理"}},[t._v("#")]),t._v(" 算法原理")]),t._v(" "),e("h3",{attrs:{id:"加密"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#加密"}},[t._v("#")]),t._v(" 加密")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("对齐")]),t._v(" "),e("p",[t._v("AES规范中，约定Block的大小固定为128bit（16Byte），也就是说，所有的加密过程是按照16字节独立来进行的。\n由于待加密的明文可能不是16字节的整数倍，所以一般第一步的处理，就是对明文进行Padding，为了确保解密时能够获得正确的明文，Padding过程具有一定的要求，比如用明文的长度除16取余，以16进制表示该余数，这样可以放在一个字节中，然后在明文后面追加该字节，直到整个明文达到16字节整数倍。不同的算法具有不同的Padding规范")])]),t._v(" "),e("li",[e("p",[t._v("分块")]),t._v(" "),e("p",[t._v("对齐之后，明文数据就可以分为同样大小的Block了，后续的加密过程，是按照Block来独立进行的，Block和Block之间没有关联")])]),t._v(" "),e("li",[e("p",[t._v("轮加密")]),t._v(" "),e("p",[t._v("这里假设密钥长度为128bit，也就是要进行10轮的加密。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。需要注意的是最后一轮迭代不执行列混合。另外，在第一轮迭代之前，需要先将明文和原始密钥进行一次异或加密操作。")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("字节代换")]),t._v(" "),e("p",[t._v("AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒")]),t._v(" "),e("p",[t._v("AES的S盒如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_Sbox.png",alt:"AES_Sbox"}})]),t._v(" "),e("p",[t._v("状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。状态矩阵经字节代换后的图如下：\n"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_02.png",alt:"AES_02"}})]),t._v(" "),e("p",[t._v("字节代换逆操作")]),t._v(" "),e("p",[t._v("逆字节代换也就是查逆S盒来变换，逆S盒如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_invSbox.png",alt:"AES_invSbox"}})])]),t._v(" "),e("li",[e("p",[t._v("行移位")]),t._v(" "),e("p",[t._v("行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_03.png",alt:"AES_03"}})]),t._v(" "),e("p",[t._v("行移位的逆变换")]),t._v(" "),e("p",[t._v("行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节。")])]),t._v(" "),e("li",[e("p",[t._v("列混合")]),t._v(" "),e("p",[t._v("列混合操作，列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_04.png",alt:"AES_04"}})]),t._v(" "),e("p",[t._v("状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_05.png",alt:"AES_05"}})]),t._v(" "),e("p",[t._v("其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。这里涉及到一些信息安全上的数学知识，不过不懂这些知识也行。其实这种二元运算的加法等价于两个字节的异或，乘法则复杂一点。对于一个8位的二进制数来说，使用域上的乘法乘以(00000010)等价于左移1位(低位补0)后，再根据情况同(00011011)进行异或运算，设S1 = (a7 a6 a5 a4 a3 a2 a1 a0)，刚0x02 * S1如下图所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_06.png",alt:"AES_06"}})]),t._v(" "),e("p",[t._v("也就是说，如果a7为1，则进行异或运算，否则不进行。\n类似地，乘以(00000100)可以拆分成两次乘以(00000010)的运算：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_07.png",alt:"AES_07"}})]),t._v(" "),e("p",[t._v("乘以(0000 0011)可以拆分成先分别乘以(0000 0001)和(0000 0010)，再将两个乘积异或：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_08.png",alt:"AES_08"}})]),t._v(" "),e("p",[t._v("因此，我们只需要实现乘以2的函数，其他数值的乘法都可以通过组合来实现。\n下面举个具体的例子,输入的状态矩阵如下：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("C9")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("E5")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("FD")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("2B")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("7A")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("F2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("78")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("6E")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("63")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("9C")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("26")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("67")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("B0")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("A7")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("82")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("E5")])])])]),t._v(" "),e("p",[t._v("下面，进行列混合运算：\n以第一列的运算为例：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_09.png",alt:"AES_09"}})]),t._v(" "),e("p",[t._v("其它列的计算就不列举了，列混合后生成的新状态矩阵如下：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("D4")]),t._v(" "),e("th",[t._v("E7")]),t._v(" "),e("th",[t._v("CD")]),t._v(" "),e("th",[t._v("66")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("28")]),t._v(" "),e("td",[t._v("02")]),t._v(" "),e("td",[t._v("E5")]),t._v(" "),e("td",[t._v("BB")])]),t._v(" "),e("tr",[e("td",[t._v("BE")]),t._v(" "),e("td",[t._v("C6")]),t._v(" "),e("td",[t._v("D6")]),t._v(" "),e("td",[t._v("BF")])]),t._v(" "),e("tr",[e("td",[t._v("22")]),t._v(" "),e("td",[t._v("0F")]),t._v(" "),e("td",[t._v("DF")]),t._v(" "),e("td",[t._v("A5")])])])]),t._v(" "),e("p",[t._v("逆向列混合变换可由下图的矩阵乘法定义：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_10.png",alt:"AES_10"}})])]),t._v(" "),e("li",[e("p",[t._v("轮密钥加")]),t._v(" "),e("p",[t._v("轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示。其中，密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位比特字，包含4个字节，他们的生成算法下面在下面介绍。轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0 S1 S2 S3 组成的32位字与W[4i]的异或运算")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_11.png",alt:"AES_11"}})]),t._v(" "),e("p",[t._v("轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位")])])])])]),t._v(" "),e("h3",{attrs:{id:"解密"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解密"}},[t._v("#")]),t._v(" 解密")]),t._v(" "),e("p",[t._v("下图展示了AES解密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/AES_13.png",alt:"AES_12"}})])])}),[],!1,null,null,null);e.default=a.exports}}]);