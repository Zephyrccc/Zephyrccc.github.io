(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{418:function(a,t,s){"use strict";s.r(t);var r=s(4),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"rsa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rsa"}},[a._v("#")]),a._v(" RSA")]),a._v(" "),t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),t("ul",[t("li",[a._v("RSA公开密钥密码体制是一种使用不同的加密密钥与解密密钥，“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制")]),a._v(" "),t("li",[a._v("在公开密钥密码体制中，加密密钥（即公开密钥）PK是公开信息，而解密密钥（即秘密密钥）SK是需要保密的。加密算法E和解密算法D也都是公开的。虽然解密密钥SK是由公开密钥PK决定的，但却不能根据PK计算出SK")]),a._v(" "),t("li",[a._v("正是基于这种理论，1978年出现了著名的RSA算法，它通常是先生成一对RSA密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位。这就使加密的计算量很大")])]),a._v(" "),t("h2",{attrs:{id:"安全性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安全性"}},[a._v("#")]),a._v(" 安全性")]),a._v(" "),t("ul",[t("li",[a._v("RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，也并没有从理论上证明破译。RSA的难度与大数分解难度等价。因为没有证明破解RSA就一定需要做大数分解。假设存在一种无须分解大数的算法，那它肯定可以修改成为大数分解算法，即RSA的重大缺陷是无法从理论上把握它的保密性能如何，而且密码学界多数人士倾向于因子分解不是NPC问题")]),a._v(" "),t("li",[a._v("目前，RSA的一些变种算法已被证明等价于大数分解。不管怎样，分解n是最显然的攻击方法。现在，人们已能分解140多个十进制位的大素数。因此，模数n必须选大些，视具体适用情况而定")]),a._v(" "),t("li",[a._v("RSA算法的保密强度随其密钥的长度增加而增强。但是，密钥越长，其加解密所耗用的时间也越长。因此，要根据所保护信息的敏感程度与攻击者破解所要花费的代价值不值得以及系统所要求的反应时间来综合考虑，尤其对于商业信息领域更是如此")])]),a._v(" "),t("h2",{attrs:{id:"算法原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法原理"}},[a._v("#")]),a._v(" 算法原理")]),a._v(" "),t("p",[a._v("RSA基于一个十分简单的数论事实：将两个大素数相乘十分容易，但想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥，即公钥，而两个大素数组合成私钥。公钥是可发布的供任何人使用，私钥则为自己所有，供解密之用")]),a._v(" "),t("h3",{attrs:{id:"rsa公私钥生成流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rsa公私钥生成流程"}},[a._v("#")]),a._v(" RSA公私钥生成流程")]),a._v(" "),t("ol",[t("li",[a._v("随机找两个质数P和Q，P与Q越大，越安全。（例如：61和53）")]),a._v(" "),t("li",[a._v("计算p和q的乘积n。（n=61×53=3233，n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位）")]),a._v(" "),t("li",[a._v("计算 n 的欧拉函数φ(n)。（根据公式φ(n)=(p-1)(q-1)算出φ(3233)等于60×52，即3120）")]),a._v(" "),t("li",[a._v("随机选择一个整数e，条件是1<e<φ(n)，且e与φ(n) 互质。（条件是1<e<φ(n)，且e与φ(n) 互质。1到3120之间，随机选择了17）")]),a._v(" "),t("li",[a._v("有一个整数d，可以使得ed 除以φ(n) 的余数为 1。（ed ≡ 1 (mod φ(n))，即17*2753 mode 3120=1）")]),a._v(" "),t("li",[a._v("将n和e封装成公钥，n和d封装成私钥。（n=3233，e=17，d=2753，所以公钥就是：3233,17，私钥就是：3233, 2753）")])]),a._v(" "),t("h3",{attrs:{id:"rsa加密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rsa加密"}},[a._v("#")]),a._v(" RSA加密")]),a._v(" "),t("p",[a._v("首先对明文进行比特串分组，使得每个分组对应的十进制数小于n，然后依次对每个分组m做一次加密，所有分组的密文构成的序列就是原始消息的加密结果，即m满足0<=m<n，则加密算法为：c=m^e mod n; c为密文，且0<=c<n")]),a._v(" "),t("h3",{attrs:{id:"rsa解密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rsa解密"}},[a._v("#")]),a._v(" RSA解密")]),a._v(" "),t("p",[a._v("对于密文0<=c<n，解密算法为：m=c^d mod n")])])}),[],!1,null,null,null);t.default=v.exports}}]);